# Architecture Comparison: Monolith vs. Microservices  

This document compares the two architectural approaches proposed for **TechEvent Hub**, highlighting the trade-offs regarding the specific constraints of the project (e.g., high traffic spikes during ticket sales).  

| Aspect | Monolithic Architecture | Microservices Architecture | Winner & Why |
| :--- | :--- | :--- | :--- |
| **Scalability** | **Horizontal Scaling:** Must replicate the entire application, even if only one module (e.g., Ticketing) is under load. Resources are wasted on idle modules. | **Granular Scaling:** Individual services (e.g., Ticketing) can be scaled up independently during sales spikes without provisioning extra resources for the Sponsor or Auth services. | **Microservices:** Crucial for TechEvent Hub's requirement to handle 50k concurrent requests during ticket launches efficiently. |
| **Fault Tolerance** | **Low Isolation:** A memory leak or critical bug in the "Networking" module could crash the entire server, taking down the Ticketing system as well. | **High Isolation:** If the "Sponsor Service" fails, the core functionality (Ticketing, Schedule) remains operational. | **Microservices:** Ensures higher availability. The show must go on; an error in a peripheral feature shouldn't stop ticket sales. |
| **Operational Complexity (DevOps)** | **Low:** Single deployment artifact, centralized logging, monitoring is straightforward. Ideal for small teams. | **High:** Requires complex orchestration (Kubernetes), service discovery, distributed tracing, and management of multiple databases. | **Monolith:** Much simpler to set up and manage initially. Microservices introduce significant "tax" on infrastructure management. |
| **Technology Stack** | **Rigid:** The entire application uses a single language/framework (e.g., Java/Spring). Hard to experiment with new tech. | **Flexible (Polyglot):** The "Networking" service can use Python for AI matching, while the "Chat" uses Node.js, and "Ticketing" uses Go for performance. | **Microservices:** Best for this project, as it allows using the right tool for specific jobs (like AI for the matchmaker). |
| **Data Consistency** | **Strong Consistency:** ACID transactions are easy to enforce within a single database. | **Eventual Consistency:** Distributed transactions (Sagas) are complex. Data may be temporarily out of sync between services. | **Monolith:** Handling payments and inventory atomically is far simpler in a monolith. Microservices require complex patterns to ensure data integrity. |
| **Deployment Speed** | **Slow & Risky:** A small change requires recompiling and redeploying the entire application. High risk of regression. | **Fast & Independent:** Teams can deploy updates to the "Schedule" service without coordinating with the "Payment" team. | **Microservices:** Allows for faster time-to-market and continuous delivery, which is vital for bug fixing during a live event. |
